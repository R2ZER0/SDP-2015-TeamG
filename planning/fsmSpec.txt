machineParams
name 			simpleAttackerFSM
inAlph			ballInZone, notBallInZone, notGotBallYet, gotBall, atPoint, notAtPoint, stillShooting, shotComplete, leavingZoneLeft, leavingZoneRight, defenderHasBall, taskIsMirroring, taskNotMirroring
states 			initial, acquiringBall, movingToPoint, shooting, centering, mirroring
initialState	initial
finalState		unnec

transitions
<*, leavingZoneLeft, [MoveToPoint, world, robot, role, world.pitch.zones[world.our_attacker.zone].center()[0], world.pitch.zones[world.our_attacker.zone].center()[1]], centering>
<*, leavingZoneRight, [MoveToPoint, world, robot, role, world.pitch.zones[world.our_attacker.zone].center()[0], world.pitch.zones[world.our_attacker.zone].center()[1]], centering>

<*, taskNotMirroring defenderHasBall, [MirrorObject, world, robot, role, world.our_defender], mirroring>

<mirroring, ballInZone, [AcquireBall, world, robot, role], acquiringBall>
<mirroring, defenderHasBall, [EXISTING], mirroring>

<centering, notAtPoint, [EXISTING], centering>
<centering, atPoint, [EXISTING], initial>

<initial, ballInZone, [AcquireBall, world, robot, role], acquiringBall>
<initial, notBallInZone, [EXISTING], initial>

<acquiringBall, gotBall, [MoveToPoint, world, robot, role, choose_attacker_destination(world)[0], choose_attacker_destination(world)[1], 10], movingToPoint>
<acquiringBall, notGotBallYet, [EXISTING], acquiringBall>
<acquiringBall, notBallInZone, [MoveToPoint, world, robot, role, 270, 150, 10], initial>

<movingToPoint, atPoint, [Shoot, world, robot, role] , shooting>
<movingToPoint, notAtPoint, [EXISTING], movingToPoint>

<shooting, shotComplete, [MoveToPoint, world, robot, role, 150, 150, 10] , initial>
<shooting, stillShooting, [EXISTING], shooting>

lambdaConditions
"taskIsMirroring": lambda planner: isinstance(planner.current_task, MirrorObject)
"taskNotMirroring": lambda planner: not isinstance(planner.current_task, MirrorObject)

"leavingZoneLeft": lambda planner:  (planner.our_robot.x - planner.world.pitch.zones[planner.our_robot.zone].boundingBox()[0]) < 5
"leavingZoneRight": lambda planner: (planner.world.pitch.zones[planner.our_robot.zone].boundingBox()[1] - planner.our_robot.x) < 5

"defenderHasBall": lambda planner:  planner.world.pitch.zones[planner.world.our_defender.zone].isInside(planner.world.ball.x, planner.world.ball.y)

"ballInZone" : lambda planner :     planner.world.pitch.zones[planner.our_robot.zone].isInside(planner.world.ball.x, planner.world.ball.y)
"notBallInZone" : lambda planner :     not planner.world.pitch.zones[planner.our_robot.zone].isInside(planner.world.ball.x, planner.world.ball.y)

"notGotBallYet" : lambda planner :  planner.current_task != None and isinstance(planner.current_task, AcquireBall) and not planner.current_task.complete
"gotBall" : lambda planner :        planner.current_task != None and isinstance(planner.current_task, AcquireBall) and planner.current_task.complete

"atPoint" : lambda planner :        planner.current_task != None and isinstance(planner.current_task, MoveToPoint) and planner.current_task.complete
"notAtPoint" : lambda planner :	    planner.current_task != None and isinstance(planner.current_task, MoveToPoint) and not planner.current_task.complete

"stillShooting" : lambda planner :	planner.current_task != None and isinstance(planner.current_task, Shoot) and not planner.current_task.complete
"shotComplete" : lambda planner :	planner.current_task != None and isinstance(planner.current_task, Shoot) and planner.current_task.complete